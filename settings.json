{
  "cathedra": "MO ЭВМ",
  "discipline": "Программирование",
  "theme": "Генерация отчетов",
  "number": "1",
  "group": "7382",
  "student": "Глазунов С.А.",
  "teacher": "Кринкин К.В.",
  "sense of work": "это самая первая версия данной программы",
  "download": ["test.c","test2.c"],
  "PDF": true ,
  "text": "Здесь может быть любой текст,любой длины, в будущем можно будет вставлять картинки и прочее другое,а также будут разные виды работ-курсовые,лабораторные и так далее",
  "init_data": "В качестве основы для курсовой работы используется код лабораторной работы No4.",
  "context_of_explanation": "«Введение», «Заключение», «Список использованных источников»",
  "min_pages": "5",
  "date_start": "28.11.2017",
  "date_finish": "23.12.2017",
  "date_defend": "23.12.2017",
  "annotation": "Необходимо, имея код лабораторной работы No4, реализовать алгоритм,который делает следующие преобразования со списком:\n• Отсортировать список по невозрастанию по полю year в этом списке;\n• Менять местами элементы не затрагивая поля, кроме тех, что указывают наследующие и предыдущие элементы;\nПишется две функции, которые производят все эти преобразования и возвращают головной элемент списка.",
  "introduction": "Необходимо, имея код лабораторной работы No4, реализовать алгоритм,который делает следующие преобразования со списком:\n• Отсортировать список по невозрастанию по полю year в этом списке;\n• Менять элементы не трогая поля, кроме тех, которые указывают на следующий и на предыдущий элемент;",
  "content": 
  [
    {
    "head":"РЕАЛИЗАЦИЯ ФУНКЦИЙ",
    "text":"На вход функции, которая названа llist_bubble_sort () подается адрес первого элемента списка, который условно назван “head”. Внутри llist_bubble_sort () была использована функция swap(), на вход которой подается 2 элемента(подразумевается, что первый аргумент является левым элементом списка второго аргумента) и адрес “head”, а также функция count(), написанная ранее для лабораторной работы No4, чтобы подсчитать количество элементов списка.",
    "image":""
    },
    {
      "head": "Сортировка списка",
      "text": "Изначально нужно определить, сколько элементов будет в списке. Для этого вызовем функцию count(). Также потребуется 2 новый указателя , которые изначально будут указывать на “head” и “head->next” соответственно.",
      "image":""
    },
    {
      "head":"Реализация:",
      "text":"Создаем переменную len, которая будет хранить количество элементов списка, и присваиваем ей значение: $$int k=count(*head)$$ ;Далее инициализируем другие переменные, которые будут являться указателями на “head” и “head->next”:Struct MusicalComposition* cur1*cur2; Далее начинается первый цикл: $$for (int j=0; j<len-1; j++)$$ ;Переменная j<len-1 ,потому что указатель cur2 из пункта  указывает наследующий элемент первого. Когда бы наступила последняя итерация цикла то cur2 указывал уже на несуществующий элемент списка, что могло бы повлечь за собой ошибку сегментации.Дальше во внутри 1-ого цикла есть еще и второй цикл, который при каждой итерации первого цикла проходит по len-1-j элементов списка.Уже во 2-ом цикле происходит сравнение поля year двух элементов списка.Если cur1->year меньше cur2->year , то вызывается функция swap, которая меняет элементы местами (См. Рис. 1).",
      "image":"1.png"
    },
    {
      "head":"",
      "text": "Теперь рассмотрим функцию swap. В функции swap надо рассмотреть 3 случая:1.Меняется “head” со следующим элементом;2.Меняется два элемента списка, ни один из которых не является головой или хвостом списка;3.Меняется хвост и предыдущий элемент.Для каждого случая нужен свой блок кода, состоящий из двух условий,поэтому в каждом блоке есть команда return – это сделано для того, чтобы Функция не проверяла лишние условия, когда заведомо следующие условия ложны (См. Рис. 2).",
      "image":"2.png"
    },
    {
      "head":"Принцип работы функции swap:",
      "text":"Так как мы работаем в линейном двусвязном списке, то для того, чтобы поменять два элемента местами в общем случае надо поменять 6 связей в сумме. По две связи у элементов, которые должны поменяться местами и по одной связи у элементов, которые до cur1 и после cur2. В cur1->prev надо поменять указатель next с cur1 на сur2. В cur2->next надо поменять указатель prev с cur2 на cur1. В сur1 надо поменять prev с cur1->prev на cur2, next поменять с cur2 на cur2->next(аналогично cur1->next->next). В cur2 надо поменять prev с cur1 на cur1->prev и next поменять с cur2->next на cur1.Cледует отметить, что менять адреса самих указателей не рекомендуется,потому что возможна потеря адреса какого элемента и в последствии приведет к неправильной работе программы.  случаях когда меняется голова или хвост следует лишь отметить, что один из казателей будет указывать на NULL, и поэтому код программы для этих случаев будет лишь слегка отличаться от общего случая.",
      "image":""
    },
    {
      "head":"Как запускается программа.",
      "text":"Вся программа состоит из нескольких файлов. Один файл-main.c, который и содержит код для выполнения основной задачи. Главные функции этого файла уже были описаны ранее в 4 лабораторной и в пункте 1 В файле “course.sh” содержится скрипт на языке bash. Благодаря этому скрипту можно передать основной программе (main.c) любой файл, который содержит текст и лежит в одной директории. Также в этом файле реализована утилита beep(См.Рис.3). Она нужна для того, чтобы компьютер подал звуковой сигнал,когда программа завершится. Это сделано для удобства программиста, так как если список будет состоять из тысячи и больше элементов, то сортировка может занять некоторое время.",
      "image":"3.png"
    },
    {
      "head":"ДЕМОНСТРАЦИЯ РАБОТЫ ПРОГРАММЫ",
      "text":"Для того, чтобы показать работу функции llist_bubble_sort () используем код функции main из лабораторной работы No4 и исходные данные из нее же.Внутри функци main() происходит считывание значений и создание списка,состоящего из структур MusicalComposition, которые содержат: название группы,альбома, год выхода альбома и указатели на предыдущий и следующий элементы списка.",
      "image":""
    },
    {
      "head":"",
      "text":"Сначала проверяется возможен ли push в списке и подсчет элементов(См.Рис.4).",
      "image":"4.png"
    },
    {
      "head":"",
      "text":"Дальше идет сортировка списка функцией llist_bubble_sort () и после удаления одного элемента(См.Рис.5).",
      "image":"5.png"
    },
    {
      "head":"ЗАКЛЮЧЕНИЕ",
      "text":"Была поставлена задача – отсортировать список по убыванию поля year.Написанные функции llist_bubble_sort и swap успешно справляются с поставленной задачей.",
      "image":""
    }
  ]
}
